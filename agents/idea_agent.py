#!/usr/bin/env python3
"""
Idea Agent - Uses Claude to generate original project ideas and ships them to GitHub.

Usage:
    python idea_agent.py [optional_theme]
    
Generates creative, useful project ideas using AI, then creates real GitHub repos.
"""

import subprocess
import random
import string
import sys
import os
import json
import re
from pathlib import Path

# Load environment variables from .env
def load_env():
    env_path = Path(__file__).parent.parent / ".env"
    if env_path.exists():
        with open(env_path) as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    os.environ[key] = value

load_env()

try:
    import anthropic
except ImportError:
    print("Installing anthropic package...")
    subprocess.run([sys.executable, "-m", "pip", "install", "anthropic", "-q"])
    import anthropic


def generate_unique_suffix():
    """Add a short random suffix to avoid repo name collisions."""
    return ''.join(random.choices(string.ascii_lowercase + string.digits, k=4))


def generate_idea_with_claude(theme=None):
    """Use Claude to generate an original project idea."""
    
    client = anthropic.Anthropic(api_key=os.environ.get("ANTHROPIC_API_KEY"))
    
    theme_prompt = f" Focus on the theme: {theme}." if theme else ""
    
    prompt = f"""Generate a creative, useful software project idea that could get stars on GitHub.{theme_prompt}

Requirements:
- Should be a focused micro-tool (not a huge framework)
- Should solve a real problem developers or users have
- Should be implementable in a reasonable timeframe
- Name should be catchy, lowercase, one word or hyphenated

Respond in this exact JSON format (no markdown, just JSON):
{{
    "name": "project-name",
    "tagline": "A short catchy description under 60 chars",
    "description": "A paragraph explaining what it does and why it's useful",
    "category": "CLI Tool / Web App / Library / Dev Tool / etc"
}}"""

    message = client.messages.create(
        model="claude-sonnet-4-20250514",
        max_tokens=500,
        messages=[
            {"role": "user", "content": prompt}
        ]
    )
    
    response_text = message.content[0].text.strip()
    
    # Parse JSON from response
    try:
        # Try to extract JSON if wrapped in anything
        json_match = re.search(r'\{[^{}]*\}', response_text, re.DOTALL)
        if json_match:
            idea = json.loads(json_match.group())
        else:
            idea = json.loads(response_text)
        return idea
    except json.JSONDecodeError as e:
        print(f"Failed to parse Claude response: {response_text}")
        raise e


def generate_readme(name, tagline, description, category):
    """Generate a README for the project."""
    return f"""# {name} ğŸš€

> {tagline}

## What is this?

{description}

## Installation

```bash
# Coming soon
pip install {name}
```

## Usage

```bash
# Coming soon
{name} --help
```

## Why?

Because sometimes you just need a tool that does one thing well.

## Category

{category}

## Status

ğŸŒ± **Just planted** â€” This repo was created by an AI agent as part of the [AgentsCreate](https://github.com/Yoakshat/AgentsCreate) experiment.

*This idea was generated by Claude and shipped autonomously.*

---

*Built by agents, judged by stars.* â­
"""


def create_repo(name, tagline, readme_content):
    """Create the GitHub repo and push the README."""
    # Create temp directory
    repo_dir = f"/tmp/{name}"
    
    # Clean up if exists
    if os.path.exists(repo_dir):
        subprocess.run(["rm", "-rf", repo_dir], capture_output=True)
    
    os.makedirs(repo_dir, exist_ok=True)
    
    # Write README
    readme_path = os.path.join(repo_dir, "README.md")
    with open(readme_path, "w") as f:
        f.write(readme_content)
    
    # Git init and commit
    subprocess.run(["git", "init"], cwd=repo_dir, capture_output=True)
    subprocess.run(["git", "add", "README.md"], cwd=repo_dir, capture_output=True)
    subprocess.run(
        ["git", "commit", "-m", f"Initial commit: {tagline}"],
        cwd=repo_dir,
        capture_output=True
    )
    
    # Create GitHub repo and push
    result = subprocess.run(
        [
            "gh", "repo", "create", name,
            "--public",
            "--source=.",
            "--push",
            "--description", tagline[:100]  # GitHub limits description length
        ],
        cwd=repo_dir,
        capture_output=True,
        text=True
    )
    
    if result.returncode == 0:
        # Extract URL from output
        for line in result.stdout.split('\n') + result.stderr.split('\n'):
            if 'github.com' in line:
                return True, line.strip()
        return True, f"https://github.com/Yoakshat/{name}"
    else:
        return False, result.stderr


def main():
    theme = sys.argv[1] if len(sys.argv) > 1 else None
    
    print("ğŸ¤– Idea Agent activated...")
    print("ğŸ§  Asking Claude for an original idea...")
    print()
    
    # Generate idea with Claude
    try:
        idea = generate_idea_with_claude(theme)
    except Exception as e:
        print(f"âŒ Failed to generate idea: {e}")
        return 1
    
    base_name = idea["name"].lower().replace(" ", "-")
    tagline = idea["tagline"]
    description = idea["description"]
    category = idea["category"]
    
    # Add suffix to make unique
    suffix = generate_unique_suffix()
    name = f"{base_name}-{suffix}"
    
    print(f"ğŸ’¡ Idea: {name}")
    print(f"ğŸ“ Tagline: {tagline}")
    print(f"ğŸ“ Category: {category}")
    print(f"ğŸ“„ Description: {description[:100]}...")
    print()
    
    # Generate README
    readme = generate_readme(base_name, tagline, description, category)
    
    print("ğŸ”¨ Creating repository...")
    success, result = create_repo(name, tagline, readme)
    
    if success:
        print(f"âœ… Success! Repository created:")
        print(f"   {result}")
    else:
        print(f"âŒ Failed: {result}")
    
    print()
    return 0 if success else 1


if __name__ == "__main__":
    sys.exit(main())
